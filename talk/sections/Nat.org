* handwavy 

tuple = { a: Nat, b: Nat }

add = tuple u { z = a + b }

res = add u { a= 1, b = 2 }

/IMG the graphs based on sets and what each field is pointing to.

{ a: Nat
  a = 1
  b: Nat
  b = 2
  res = a + b
}

* we have variable depending in other variable in the set.

res.z = ...

* e.g. 
val onePlusTwo = { a: Nat
  a = 1
  b: Nat
  b = 2
  res = /* a + b/3 */
}
We can project the parameters to the application

* We see that in STACC we follow the opposite path
    Everything is reified, so any language on top of Stacc would have to erase aggresively all the encodings of function application as data 

   --  To be usable with a familiar FP language all the encoding of function will need to be erased on application


* An AST is a tree
   Really it is a DAG because we have references. Recursive definitions
i

{ a: Nat
  b: Nat
  z = /* a + b */
}

* Show example
   Nat = { pres: Nat }

    
* Static vies of function application 

{ 
   a: Nat

   c: a
}

* Components of STACC
   Sets of predicates on variables:

   the only terminal object is {}
   then there are variables, or labels
 
   built in predicates are equality and membership

   There is canonical equality.

     {
       a = {}
    
       b = {}

       b = a
     }

   {
      a = { z = {} }
     
      b = { z = {} }

      a = b

   }


   {
      a = { z = {} }
     
      b = { y = {} }

      a = b

   } // FAIL

* Membership
   - A predicate creates a set of values

    a e P,  is the same as P(a) in logic

* One builin Predicate
   INSET



* Structural
  Outer names do not matter

::: Recursivity to mame types more interesting ??? inductivity

::: Introduce Nat

Nat = Succ | {}
Succ = { pred: Nat }

zero = {}
one  = Succ u { pred = {} } // one = { pred = {} } equivalent:

* Structural
  Outer names do not matter

one  = Succ u { pred = {} }

one = { pred = {} } equivalent:

both are members of Nat, despite construction is different:
a) { 
       pred: Nat
       pred = {}
}   vs { pred = {} }

both are equivalent under unification / canonicity, as pred: Nat is redundant as soon as we have pred with value {}
pred: Nat is subsumed in the information that pred = {}

Constructivism, local reasoning on overload. We don't need the lineage of the object to check it's properties. 

--- bbbeeee Lineage is important to remember proofs? but they can be carried, so the lineage is not fundamental ---




::: Convert into a list  

::: Introduce polimorphism
   
::: dependant typing

     
 
